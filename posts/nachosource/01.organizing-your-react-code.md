---
title: Organizing your React code
published: false
description:
tags: 'react, javascript'
cover_image:
---

Have you ever needed to review your own code, written just a couple months ago, and had to spend a considerable amount of time guessing what you were trying to do? Have you ever been assigned to a new project to find a pile of messy and eternal files? Have you had the feeling that a bug fix that took your day could have been solved in a fraction of that time only by having the code a little more organized?

These are common situations that make you, at least, wonder if things could have been done better (even if it was you screwing it up!).
Consequences of spaghetti code are usually spending days instead of hours solving problems, code repetition, inconsistencies between behaviors that should work the same way, inaccurate estimations and, of course, some headaches.

In this post I’ll share some concepts that help me when it comes to designing clean and maintainable components, architecture and logic.

## Don’t let yourself be pushed (by the urgencies)

We all know that things must be delivered as fast as they can be: the time pressure exists. But keep in mind that today’s mistakes are costing you in the future.
Don’t give more importance to matching the deadline than to building a robust logic. I’m sure that once you’ve learnt how to make things done it’s easy for you to deliver something that works. But don’t forget that this logic could need to be reused in the future, or even change.
So make sure that you won’t need to rebuild a whole component every time a style changes or a prop is added.

## Cohesion and coupling

These two are key concepts that will go along with wherever you code. Since they’ve already been explained way better than I could do here and now, I’m only talking about the core concept.

Imagine that your web has a couple of pages that share a section component. Let’s also say this section has a button that gets some data from an API, formats it and stores it somewhere in your app state, but this whole process is different each case.

It’s easy to see that we are going to reuse at least a part of our code, keeping in mind that our goal is to have as little code as possible (we’ll return to this later). The point is, which is going to be our criteria here? Is there a standard to conform to when designing our reusable component?
The golden rule is: the greatest cohesion, the lowest coupling. What does this mean? Said in a few words, cohesion is related with the criteria that gathers the inside elements of your component, while coupling has to do with the external relations established between your component and the environment in which it is used (I mean, everything else).
And let me just add that, as we have a components tree, these concepts are to be transported to wherever you want, from less to more abstract.

> For more info about this topic [_have a read_](https://betterprogramming.pub/coupling-cohesion-552b022492b2).

Why do we want our components to be cohesive and decoupled? The stronger relation you achieve between your inside elements, the more definite and accurate the identity of your component is. The more abstracted you keep from the external requirements, the freer you get to reuse and adapt your components to different situations.

Should I declare every single behavior the button could have when handling the click? Seems we could get a handler from our props, decoupling our logic from the one depending on foreign elements.
Are you sure it’s clean to fill your component with `if`s to validate what to render or not according to every possible use case? Let’s have a simple one-job component as external logic is out of our scope -but inside another component’s one.

```javascript
import React from "react";

const MyComponent = (props) => {
  const { isHeader = false, isFooter = false, text } = props;

  const headerTitle = isHeader ? "MyHeader" : "";
  const footerTitle = isFooter ? "MyFooter" : "";
  const styles = isHeader
    ? {
        backgroundColor: "red",
        fontWeight: "bold",
        width: "200px",
      }
    : {
        backgroundColor: "green",
        fontWeight: "lighter",
        width: "500px",
      };

  const headerClickHandler = () => console.log("I'm a header");
  const footerClickHandler = () => console.log("I'm a footer");

  return (
    <div style={styles}>
      {isHeader && <p>{headerTitle}</p>}
      <p>{text}</p>
      <button onClick={isHeader ? headerClickHandler : footerClickHandler}>
        Click Me!
      </button>
      {isFooter && <p>{footerTitle}</p>}
    </div>
  );
};

export default MyComponent;
```

```javascript
import React from "react";

const MyComponent = ({ styles, text, handleClick }) => (
  <div style={styles}>
    <p>{text}</p>
    <button onClick={handleClick}>Click Me!</button>
  </div>
);

const Header = () => {
  const headerStyles = {
    backgroundColor: "green",
    fontWeight: "bold",
    width: "200px",
  };
  const headerTitle = "MyHeader";

  return (
    <div>
      <p>{headerTitle}</p>
      <MyComponent
        styles={headerStyles}
        text="Footer"
        handleClick={() => {
          console.log("I'm a Header");
        }}
      />
    </div>
  );
};

const Footer = () => {
  const footerStyles = {
    backgroundColor: "green",
    fontWeight: "lighter",
    width: "500px",
  };
  const footerTitle = "MyFooter";

  return (
    <div>
      <MyComponent
        styles={footerStyles}
        text="Footer"
        handleClick={() => {
          console.log("I'm a Footer");
        }}
      />
      <p>{footerTitle}</p>
    </div>
  );
};

const ContainerComponent = () => (
  <div>
    <Footer />
    <Header />
  </div>
);

export default ContainerComponent;
```

> Have you heard about the [_single-responsibility_](https://www.geeksforgeeks.org/how-to-use-single-responsibility-principle-in-reactjs/) principle?

## Organize your files

One of the keys to have your code clean is to do the most with the least amount of code. When we get our components reusable we are also making an effort to improve the code’s readability and comprehension, compressing our files as much as possible.
Even if you’re not planning to reuse a code block all around the code, it’s nice to have it as an independent and self-descriptive component in its own file. This way it’s easy to get what it is used for (and, again, to abstract it from the context).

If you do so, you are avoiding those thousand-line files that make you read line by line of logic that you don’t need until you find your spot.

One more thing about your files: once you’ve spread your blocks into functional components you can see that it’s hard to find each one amongst a large list of them, and even to name them!
Don’t forget to create some directories that gather these files using any criteria you want.

See the difference:

![files](./files.png)

But what are the `index` files for? There you can organize the exports in order to have your files clean when importing them.

```javascript
import MainHeader from "./MainHeader";
import NewsCarousel from "./NewsCarousel";
import ProductsList from "./ProductsList";

export { MainHeader, NewsCarousel, ProductsList };
```

The person on the left is a responsible developer who follows the best practices. The one on the right is his twin brother, who thinks it’s fine to copy&paste the same logic over and over again and concentrate his code in a few files.
Choose your cards wisely!

![people](./people.png)
